/**
 * Entry.c
 *
 * Application entry point.
 * This file was automatically generated by IngeDev and must be filled out
 * by the developer.
 *
 * Purpose:
 *
 * Each time Manager calls an application, it generates only one service
 * call that reaches your application main with the corresponding service
 * number.
 *
 * List of routines in file:
 * - give_your_domain: Return application domain.
 * - after_reset: Application reset processing.
 * - is_name: Report application name to Manager.
 * - is_state: Return application status (initialize or not).
 * - idle_message: Dedicated to display idle message.
 * - more_function: Dedicated to navigation menus.
 * - keyboard_event: Return key pressed.
 * - state: Print terminal content.
 * - consult: Print daily totals.
 * - mcall: Print call schedule.
 * - is_time_function: Need pheripherals at the next call time_function()
 * - time_function: Allow automatic execution of periodic functions.
 * - is_change_init: Conditions for changing manager parameters?
 * - modif_param: Manager reports parameters changing.
 * - is_evol_pg: Conditions for application downloading?
 * - is_delete: Conditions for application deletion?
 * - file_received: Manager reports parameters file received from LLT.
 * - message_received: Inter application messaging.
 * - is_card_specific: Card needs a specific process?
 * - card_inside: Transaction in progress for a specific card.
 * - is_for_you_before: Is chip card as an ISO 7816-3?
 * - is_for_you_after: recognise mag, smc or man card in order to be a candidate.
 * - give_interface: Services registration and priority.
 * - entry: Call by OS for recording services and opening DLL(s).
 */

#include <SDK30.H>

//includes do usuário
#include "Globals.h"
#include "Dialogs.h"
#include "Inicio.h"
#include "Menu.h"

extern struct Confs config;
extern struct MsgTela msgtela;

//+++++++++++++ Macros & preprocessor definitions ++++++++++++++

#define SERVICES_LOW_PRIORITY           30
#define SERVICES_HIGH_PRIORITY          10
#define SERVICES_DEFAULT_PRIORITY       20

//++++++++++++++++++++++ Global variables ++++++++++++++++++++++

static service_desc_t Services[] = {
    { 0, GIVE_YOUR_DOMAIN, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, AFTER_RESET, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IS_NAME, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IS_STATE, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IDLE_MESSAGE, (SAP)Main, (unsigned char)SERVICES_DEFAULT_PRIORITY },
    { 0, MORE_FUNCTION, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, KEYBOARD_EVENT, (SAP)Main, (unsigned char)SERVICES_DEFAULT_PRIORITY },
    { 0, STATE, (SAP)Main, (unsigned char)SERVICES_DEFAULT_PRIORITY },
    { 0, CONSULT, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, MCALL, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IS_TIME_FUNCTION, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, TIME_FUNCTION, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IS_CHANGE_INIT, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, MODIF_PARAM, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IS_EVOL_PG, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IS_DELETE, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, FILE_RECEIVED, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, MESSAGE_RECEIVED, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, IS_CARD_SPECIFIC, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, CARD_INSIDE, (SAP)Main, (unsigned char)SERVICES_DEFAULT_PRIORITY },
    { 0, IS_FOR_YOU_AFTER, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY },
    { 0, DEBIT_NON_EMV, (SAP)Main, (unsigned char)SERVICES_HIGH_PRIORITY }
};

typedef struct Params
{
    char Old_Date[24+1];
    char Old_FmtDate[24+1];
    char Old_Language[24+1];
    char Old_Pabx[24+1];
    char Old_PPad[24+1];
    char Old_PPadType[24+1];
    char Old_ISOreader[24+1];
    char Old_TMSaccess[24+1];
} S_PARAMS;

static char appName[OBJECT_NAME_LEN + 1];
static char fileName[OBJECT_FILE_NAME_LEN + 1];
static const char coldReset[] = "Cold Reset\nFrom OPUS";
static const char warmReset[] = "Warm Reset\nFrom OPUS";
static const char timeToCall[] = "Time to call\nFrom ";
static const char szDate[] = "Date:%.2s/%.2s/%.2s  %.2s:%.2s\n";

int idleMsgAtual = 1;

/**
 * Ask application to define its working environment, Manager will select
 *  common parameters set and adapt its internal processing.
 * \param    no (-I)
 * \param    p1 (-I)
 * \param    param_out (-O)
 *                          - application_type: TYP_CARTE (French Bank)
 *                                              TYP_HEALTH(French Health)
 *                                              TYP_EXPORT (Export)
 *                          - mask:  Key "F" 031 -> Parameters initialization (0:absent, 1:present)
 *                          - response_number: should be incremented
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int give_your_domain(NO_SEGMENT no, void *p1, S_INITPARAMOUT *param_out)
{

    // Return application domain to Manager
    // Setting parameters initialization
    param_out->returned_state[param_out->response_number].mask = MSK_MDP|MSK_SWIPE|MSK_TYPE_PPAD|MSK_PINPAD|MSK_STANDARD|MSK_LANGUE|MSK_FRMT_DATE|MSK_DATE;
    // International domain
    param_out->returned_state[param_out->response_number].application_type = TYP_EXPORT;
    param_out->response_number++;

    return (FCT_OK);
}

/**
 * Initialize data and create disks, eventually ends interrupted transaction
 *  by returning S_TRANS_OUT.
 * \param    no (-I)
 * \param    p1 (-I)
 * \param    param_out (-O) Eventually ends interrupted transaction
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int after_reset(NO_SEGMENT no, void *p1, S_TRANSOUT *param_out)
{
    unsigned char cNew;
    TYPE_CHGT cType;

    // Reset management
    first_init(no, &cNew, (unsigned char *) &cType);        // NEW SOFTWARE LOADED ?
    _clrscr();
	if (cNew == 0xFF)                     // YES, just loaded with first execution
	{
		_DrawExtendedString(0, 20, (char*) coldReset, _OFF_, _XLARGE_, _PROPORTIONNEL_);
		raz_init(no);                     // Reset indicator downloading
	}
	else                                  // NO, already loaded and executed
	{
		_DrawExtendedString(0, 20, (char*) warmReset, _OFF_, _XLARGE_, _PROPORTIONNEL_);
	}
    PaintGraphics();

    ttestall(0, 1*100);                    // Wait for 2s.

    // -- Inicialização
    Inicio();
    // ----------------

    return FCT_OK;
}

/**
 * Report application name to Manager.
 * \param    no (-I)
 * \param    p1 (-I)
 * \param    param_out (-O)
 *                          - appname: Application name
 *                          - no: Application number
 *                          - response_number: should be incremented
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int is_name(NO_SEGMENT no, void *p1, S_ETATOUT *param_out)
{
  // Report application name to Manager cannot return the family name
  // because the T_APPNAME type used in the "is_name" function is too short to store
  // the FAMILY NAME (T_APPNAME length = 12+1 FAMILY NAME length =15+1)
  // we use the binary name instead (without extension, and whose length is 11+1)

  memset(param_out->returned_state[param_out->response_number].appname,0, sizeof(param_out->returned_state[param_out->response_number].appname));
  strncpy(param_out->returned_state[param_out->response_number].appname, fileName, sizeof(param_out->returned_state[param_out->response_number].appname) - 1);
  param_out->returned_state[param_out->response_number].no_appli = no;
  param_out->response_number++;

  return (FCT_OK);
}

/**
 * Report application state initialize or not to Manager.
 * \param    no (-I)
 * \param    p1 (-I)
 * \param    param_out (-O)
 *                          - response: REP_OK (Initialized)
 *                                      REP_KO (Not initialized)
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int is_state(NO_SEGMENT no, void *p1, S_ETATOUT *param_out)
{
    int retour;

    // Return application state
    param_out->returned_state[param_out->response_number].state.response = REP_OK;
    retour = is_name (no, PT_NULL, param_out);

    return (retour);
}

/**
 * Allows the application to display its idle message when Manager goes back
 *  to idle (the application should have the higher priority).
 * \param    no (-I)
 * \param    p1 (-I)
 * \param    p2 (-I)
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int idle_message (NO_SEGMENT no, void *p1, void *p2)
{
    if (strlen(msgtela.msglin1) == 0)
    	sprintf(msgtela.msglin1, "%s", __NOMEEMP__);

    if (strlen(msgtela.msglin2) == 0)
    	sprintf(msgtela.msglin2, "Versao: %s", __APPVER__);

	// Idle message management
    if (idleMsgAtual == 1)
    	DisplayLogo();
    else
    	DisplaySimpleMessage2lines(msgtela.msglin1, msgtela.msglin2, TRUE, TRUE);

    return FCT_OK;
}

/**
 * It's activated when pressing on "F" key to select the right application
 *  to go on menu.
 * \param    no (-I)
 * \param    p1 (-I)
 * \param    p2 (-I)
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 *
 * \note Other prototype variant 'int more_function_ext(NO_SEGMENT no, S_ETATOUT *in, void *out)'
 *       can be used with INCENDO.
 *       This other prototype is used if the application manages more than one application name.
 *       The 'S_ETATOUT' structure allows to know the name selected by the user after pressing the "F" key.
 *       This new prototype can be used with SDK version >= 6.5.
 */
int more_function( NO_SEGMENT no, void *p1, void *p2 )
{
    return FCT_OK;
}

/**
 * It's activated when key is pressed and terminal is in idle mode.
 * \param    noappli
 * \param    key_in (I-)
 *                       - keycode: Key pressed.
 * \param    key_out (-O)
 *                       - keycode: Key pressed, new key, 0=disable.
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int keyboard_event(NO_SEGMENT noappli,S_KEY *key_in,S_KEY *key_out)
{
	// Keyboard management
	FILE *hKeyb = NULL;
	char cKey = 0;
	int iRet;

    switch (key_in->keycode)
    {
		case T_VAL:
			iniciarMenuPrincipal();
			key_out->keycode = 0;
			break;
		case F1:
			//se o usuário pressionar F1 novamente, abrirá um diálogo pedindo senha técnica
			hKeyb = fopen("KEYBOARD","r");

			iRet = ttestall(KEYBOARD, 50);
			if (iRet & KEYBOARD)
				cKey = getchar();

			fclose (hKeyb);

			if (cKey == F1)
				iniciarMenuSistema(0);

			key_out->keycode = 0;
			break;
		case N0: case N1: case N2: case N3: case N4:
		case N5: case N6: case N7: case N8: case N9:
		case T_POINT: case F2: case F3:
			key_out->keycode = 0;               // Inhibit these keys to Manager for International domain
			break;
		case F4 :
		case T_CORR: case T_ANN: case NAVI_CLEAR: case NAVI_OK:
		case UP : case DOWN :
			key_out->keycode = 0;
			break;
		case T_F :                              // do not filter F key and return the same key !
			key_out->keycode=key_in->keycode;   // Return the same key value for keys above !
			break;
		default :
			key_out->keycode=key_in->keycode;
			break;
    }

    return (FCT_OK);
}

/**
 * It's activated on "F" key: Consultation->State.
 *  To print terminal content.
 * \param    no (-I)
 * \param    p1 (-I)
 * \param    p2 (-I)
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int state (NO_SEGMENT no, void *p1, void *p2)
{
    DATE date;
    object_info_t infos;
    FILE     *hPrinter;

    // Print application info
    ObjectGetInfo(OBJECT_TYPE_APPLI, no, &infos);       // Retrieve application info

    hPrinter=fopen( "PRINTER", "w-*" );                 // Open printer driver
    if (hPrinter!=NULL)
    {
        pprintf("\x1b""E%s\n""\x1b""F",appName);        // Print application name
        pprintf("         STATE         \n"
                "Application used as\n"
                "IngeDev Template\n\n");
        read_date(&date);                               // Print date and time
        pprintf(szDate, date.day, date.month, date.year, date.hour, date.minute);
        pprintf("File    : %s\n",infos.file_name);      // Print application file name
        pprintf("CRC     : %04x\n",infos.crc);          // Print application CRC
        ttestall(PRINTER, 0);

        fclose(hPrinter);                               // Close printer driver
    }

    return FCT_OK;
}

/**
 * It's activated on "F" key: Consultation->Transactions.
 *  To print transactions total receipt.
 * \param    no (-I)
 * \param    p1 (-I)
 * \param    p2 (-I)
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int consult (NO_SEGMENT no, void *p1, void *p2)
{
    DATE date;
    FILE *hPrinter;

    // Print daily totals
    hPrinter=fopen("PRINTER", "w-*");                    // Open printer driver
    if (hPrinter!=NULL)
    {
        pprintf("\x1b""E%s\n""\x1b""F", appName);        // Print application name
        pprintf("        CONSULT        \n"
                "Print daily totals here\n"
                "Number of Debit/Credit \n"
                "Totals of Debit/Credit \n"
                "Number of Cancel\n\n");
        read_date(&date);                                // Print date and time
        pprintf(szDate, date.day, date.month, date.year, date.hour, date.minute);

        ttestall(PRINTER, 3*100);
        fclose(hPrinter);                                // Close printer driver
    }

    return FCT_OK;
}

/**
 * It's activated on "F" key: Consultation->Call->Planning of Call.
 *  To print call schedule receipt.
 * \param    no (-I)
 * \param    p1 (-I)
 * \param    p2 (-I)
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int mcall (NO_SEGMENT no, void *p1, void *p2)
{
    DATE date;
    FILE *hPrinter;

    // Print call schedule
    hPrinter=fopen("PRINTER", "w-*");                     // Open printer driver
    if (hPrinter!=NULL)
    {
        pprintf("\x1b""E%s\n""\x1b""F", appName);         // Print application name
        pprintf("         MCALL         \n"
                "Planning of call here  \n"
                "Time release batch     \n"
                "Time loading parameters\n"
                "Time loading hotlist\n\n");
        read_date(&date);                                 // Print date and time
        pprintf(szDate, date.day, date.month, date.year, date.hour, date.minute);

        ttestall(PRINTER, 3*100);
        fclose(hPrinter);                                 // Close printer driver
    }

    return FCT_OK;
}

/**
 * Do you need the peripherals at the next call of time_function()?.
 *  It's call every minute.
 * \param    no (-I)
 * \param    p1 (-I)
 * \param    param_out (-O)
 *                          - response: REP_OK (Manager closes all peripherals)
 *                                      REP_KO (Manager keeps all peripherals opened)
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int is_time_function(NO_SEGMENT no, void *p1, S_ETATOUT *param_out)
{
    int retour;

    // Peripherals needed?
    param_out->returned_state[param_out->response_number].state.response=REP_OK;
    retour = is_name (no, PT_NULL, param_out);

    return(FCT_OK);
}

/**
 * Allow application to execute its own periodical process.
 *  It's call every minute.
 * \param    no (-I)
 * \param    p1 (-I)
 * \param    p2 (-I)
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int time_function(NO_SEGMENT no, void *p1, void *p2)
{
    // Periodical function in progress
    /*
    fopen("DISPLAY","w");                 // Open display driver
    printf(timeToCall);
    printf(appName);

    ttestall(0, 1*100);
    fclose(stdout());                     // Close display driver
    */

	if (idleMsgAtual==1)
	{
		idleMsgAtual = 2;
	}
	else
	{
		idleMsgAtual = 1;
	}
    return (FCT_OK);
}

/**
 * It's activated on "F" key: Initialization->Parameters->List.
 *  Each time Manager wants to change its own parameters.
 * \param    no (-I)
 * \param    p1 (-I)
 * \param    param_out (-O)
 *                          - mask: Key "F" 031 -> Parameters modification (0:accepting, 1:refusing)
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int is_change_init(NO_SEGMENT no, void *p1, S_ETATOUT *param_out)
{
    S_ETATOUT etatout;
    int       retour;
    memcpy(&etatout, param_out, sizeof(etatout));

    // accept all
    etatout.returned_state[etatout.response_number].state.mask=0;
    memcpy(param_out,&etatout,sizeof(etatout));
    retour = is_name (no, PT_NULL, param_out);
    return(FCT_OK);
}

/**
 * It's activated on "F" key: Initialization->Parameters->List.
 *  Each time Manager changed its own parameters.
 * \param    noappli (I-)
 * \param    param_in (I-)
 *                         - mask: Key "F" 031 -> Parameters modification (0:not modified, 1:modified)
 * \param    p2 (-I)
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int modif_param(NO_SEGMENT noappli, S_MODIF_P *param_in, void *p2)
{
    S_MODIF_P param_changed;

    memcpy(&param_changed, param_in,sizeof(param_changed));
    fopen("DISPLAY","w");
    printf("MODIF_PARAM\n%04x",(int)param_changed.etatout.returned_state[0].state.mask);
    ttestall(0,200);
    fclose(stdout());
    return(FCT_OK);
}

/**
 * It's activated each time Manager wants to run a downloading session (local or remote).
 *  "F" key: Evolution->Load->Local or Evolution->Remote Load
 * \param    no (-I)
 * \param    p1 (-I)
 * \param    param_out (-O)
 *                          - response: REP_OK (application authorizes donwloading process)
 *                                      REP_KO (application refuses any downloading process)
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int is_evol_pg(NO_SEGMENT no, void *p1, S_ETATOUT *param_out)
{
    int retour;

    // Downloading process allowed?
    param_out->returned_state[param_out->response_number].state.response=REP_OK;
    retour = is_name (no, PT_NULL, param_out);

    return(FCT_OK);
}

/**
 * It's activated each time Manager wants to delete an application.
 *  "F" key: Deletion
 * \param    no (-I)
 * \param    p1 (-I)
 * \param    param_out (-O)
 *                          - response: DEL_YES (application authorizes deletion process)
 *                                      DEL_NO (application refuses any deletion process)
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int is_delete(NO_SEGMENT no, void *p1, S_DELETE *param_out)
{
    // Deletion process allowed?
    param_out->deleting=DEL_YES;

    return (FCT_OK);
}

/**
 * Manager reports parameters file received from LLT.
 *  It's activated upon reception of a parameter file by the manager.
 * \param    no (-I)
 * \param    param_in (I-)
 *                         - volume_name: SYSTEM (File loaded in CFS)
 *                                        HOST (File loaded in DFS).
 *                         - file_name: Application file name
 * \param    p2 (-I)
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int file_received(NO_SEGMENT no, S_FILE *param_in, void *p2)
{
    FILE *prt;
    S_FS_PARAM_CREATE ParamCreat;
    int Ret;
    char Dir_File[25];
    char Dir_Label[25];
    int len;
    char rsp[256];
    S_FS_FILE *pFile;

    // Print parameter file received
    prt=fopen("PRINTER","w-");                        // Open printer driver
    pprintf("\x1b""E%s\n""\x1b""F", appName);
    pprintf("File Received :\n/%s/%s\n",param_in->volume_name,param_in->file_name);
    ttestall(PRINTER,0);                              // Print volume+file_name

    memclr(Dir_File,sizeof(Dir_File));
    memclr(Dir_Label,sizeof(Dir_Label));

    sprintf(Dir_Label,"/%s",param_in->volume_name);
    ParamCreat.Mode = FS_WRITEONCE;
    Ret = FS_mount (Dir_Label,&ParamCreat.Mode);
    if (Ret == FS_OK)
    {
        sprintf(Dir_File,"/%s/%s",param_in->volume_name,param_in->file_name);
        pFile = FS_open (Dir_File, "r");             // The file can be open at this stage

        // Eventually read the file and get parameters
        len = FS_length(pFile);                      // File length in bytes
        if(len > sizeof(rsp)) {
          len = sizeof(rsp);
        }
        FS_read(rsp, len, 1, pFile);                 // Read from file

        FS_close(pFile);                             // Close the file
        FS_unmount(Dir_Label);                       // Cannot be deleted as it is located in system disk
    }

    pprintf("%s\n", rsp);

    fclose(prt);                                     // Close printer driver

    return (FCT_OK);
}

/**
 * Inter application messaging.
 *  It's activated each time Manager received a message in its mailbox for this application.
 * \param    no (-I)
 * \param    param_in (I-)
 *                         - sender: Sender ID
 *                         - receiver: Receiver ID
 *                         - type: IAM type
 *                         - length: Message length
 *                         - value: Message received
 * \param    p2 (-I)
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int message_received(NO_SEGMENT no, S_MESSAGE_IAM *param_in, void *p2)
{
    FILE *prt;

    // Print message received from application 2
    prt=fopen("PRINTER","w-");                                           // Open printer driver
    pprintf("\x1b""E%s\n""\x1b""F", appName);
    pprintf ("Message IAM :\n");
    pprintf ("S:%04X R:%04X\n", param_in->sender, param_in->receiver);   // USER2 to TEMPLATE
    pprintf ("IAM Type : %04X \n\n", param_in->type);

    pprintf("%s\n\n\n\n\n\n", param_in->value);                          // Print the message received
    ttestall(PRINTER, 2*100);
    fclose(prt);                                                         // Close printer driver

    return (FCT_OK);
}

/**
 * It's activated when a card is inserted, swiped or manually entry.
 * Ask the application if the card need a specific processing.
 * \param    no (-I)
 * \param    param_in (-I)
 * \param    param_out (-O)
 *                          - response: REP_OK (card processing)
 *                                      REP_KO (no card processing)
 *  Only one application wants to process the card, manager calls CARD_INSIDE entry.
 *  More application wants to process the card, manager asks for card removal.
 *  If no application wants to process the card, manager goes on with selection process.
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int is_card_specific(NO_SEGMENT no, S_TRANSIN *param_in, S_ETATOUT *param_out)
{
    int ret;

    // Return application state
    param_out->returned_state[param_out->response_number].state.response = REP_KO;
    ret = is_name (no, PT_NULL, param_out);

    return (FCT_OK);
}

/**
 * It's activated when an application has chosen to treat this card has specific.
 * The transaction is done here.
 * \param    no (-I)
 * \param    param_in (-I)
 * \param    param_out (-O)
 *                          - rc_payment: PAY_OK (Transaction done)
 *                                        PAY_KO (Transaction rejected)
 *  If an application returns STOP, polling is stopped and manager asks for card removal.
 *  The application is in charge to ask for amount and currency if needed.
 *
 * \return STOP: Card accepted and transaction process done, polling is stop.
 *         FCT_OK: Card refused and poll the next application.
 *
 * \see sdk30.h
 */
int card_inside(NO_SEGMENT no, S_TRANSIN *param_in, S_TRANSOUT *param_out)
{
    bool card_accepted = TRUE;

    if (card_accepted)
    {
    // Return transaction status
    param_out->rc_payment = PAY_OK;               // Transaction done, polling is stop
    return (STOP);
    }
    else
    {
        return (FCT_OK);                          // Card refused, poll the next application
    }
}

/**
 * Ask application to recognize the magnetic, smart or manually card in order to be
 * a candidate.
 * \param    no (-I)
 * \param    param_in (-I)
 * \param    param_out (-O)
 *                          - cardappnumber: 1 = Card accepted
 *                                           0 = Card rejected
 *                          - cardapp: CARD_PROCESSED (low priority)
 *                                     CARD_RECOGNIZED (medium priority)
 *                                     CARD_PRIORITY (high priority)
 *                          - appname: Application name
 *                          - no: Application number
 *                          - response_number: should be incremented
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int is_for_you_after(NO_SEGMENT no, S_TRANSIN *param_in, S_CARDOUT *param_out)
{

    // case of chip card
    if (param_in->support == CHIP_SUPPORT)
    {
        if(param_in->power_on_result == 0)
        {
            // accept this card
            param_out->returned_state[param_out->response_number].cardappnumber = 1;
            param_out->returned_state[param_out->response_number].cardapp [0].priority = CARD_PROCESSED;
        }
        else
        {
            // reject the card
            param_out->returned_state[param_out->response_number].cardappnumber = 0;
        }
    }

    // case of stripe 2 card
    if (param_in->support == TRACK2_SUPPORT)
    {
        // accept this card
        param_out->returned_state[param_out->response_number].cardappnumber = 1;
        param_out->returned_state[param_out->response_number].cardapp [0].priority = CARD_PRIORITY;
    }

    // case of Card Number Manual entry
    if (param_in->support == OPERATOR_SUPPORT)
    {
        // accept this card
        param_out->returned_state[param_out->response_number].cardappnumber = 1;
        param_out->returned_state[param_out->response_number].cardapp [0].priority = CARD_PRIORITY;
    }

    // give my application name
    strcpy (param_out->returned_state[param_out->response_number].appname, appName) ;
    // give my application number
    param_out->returned_state[param_out->response_number].no_appli = no;
    // give my card name
    strcpy (param_out->returned_state[param_out->response_number].cardapp [0].cardappname, "Template") ;
    // increment the response number
    param_out->response_number++;

    return (FCT_OK);
}

/**
 * Process a non EMV chip card or a magnetic card or manual entry transaction.
 * \param    no (-I)
 * \param    param_in (-I)
 * \param    param_out (-O)
 *                          - rc_payment: PAY_OK (Transaction done)
 *                                        PAY_KO (Transaction rejected)
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int debit_non_emv (NO_SEGMENT no, S_TRANSIN * param_in, S_TRANSOUT * param_out)
{
    FILE *prt;
    //int i;

    prt  = fopen("PRINTER", "w-");

    // case of chip card
    if ( param_in->support == CHIP_SUPPORT )
    {
        /*pprintf("\x1b""E%s\n""\x1b""F", appName);
        if (param_in->historical_bytes.length != 0)
        {
            pprintf("Atr:\n");
            for (i=0; i<param_in->historical_bytes.length; i++)
            {
                pprintf("%02X ", param_in->historical_bytes.historic[i]);
            }
        }
        else
        {
            pprintf("Synchronous card\n");
            pprintf("or Chip mute\n");
        }
        pprintf("\n\n\n\n\n\n");*/
    }

    // case of stripe 2 card
    if ( param_in->support == TRACK2_SUPPORT)
    {
    	/*pprintf("\x1b""E%s\n""\x1b""F", appName);
    	pprintf("Track2:\n%s\n\n\n\n\n\n", param_in->track2);*/

    	if (strcmp((char *)param_in->track2, config.cfSenhaMagn) == 0)
    	{
    		iniciarMenuSistema(1);
    	}
    }

    // case of Card Number Manual entry
    if ( param_in->support == OPERATOR_SUPPORT )
    {
        /*pprintf("\x1b""E%s\n""\x1b""F", appName);
        pprintf("Manual Entry:\n%s\n\n\n\n\n\n",param_in->track2);*/
    }

    ttestall(PRINTER,2*100);
    fclose(prt);

    param_out->noappli      = no;                 // Return application number
    param_out->rc_payment = PAY_OK;               // Transaction done
    return (FCT_OK);
}


/**
 * Services registration and priority.
 * For all services except idle_message, priority => 0x00 highest and 0xFF lowest
 * For idle_message, priority => 0x00 lowest 0xFF highest
 * \param    AppliNum (-I)
 * \param    p1 (-I)
 * \param    p2 (-I)
 *
 * \return FCT_OK
 *
 * \see sdk30.h
 */
int give_interface(unsigned short AppliNum, void *p1, void *p2)
{
    int i;

    for(i = 0; i < (int)(sizeof(Services) / sizeof(Services[0])); i++)
        Services[i].appli_id = AppliNum;

    ServiceRegister((sizeof(Services) / sizeof(Services[0])), Services);

    return FCT_OK;
}

#ifdef __cplusplus
extern "C" {
#endif

/**
 * entry() is called by the OS for recording services and opening DLL(s).
 * The RegisteryPowerFailure() can also be moved to entry().
 *
 * \see sdk30.h
 */
void entry(void)
{
  object_info_t info;
  char * indexExt;

  // Recording services
  ObjectGetInfo(OBJECT_TYPE_APPLI, ApplicationGetCurrent(), &info);
  give_interface(info.application_type, NULL, NULL);

  memcpy(appName, info.name, OBJECT_NAME_LEN);
  memcpy(fileName, info.file_name, OBJECT_FILE_NAME_LEN);
  fileName[OBJECT_FILE_NAME_LEN] = '\0';
  appName[OBJECT_NAME_LEN] = '\0';

  // In the string given to the "is_name" function
  // FAMILY NAME cannot be used because the T_APPNAME type used in is_name function is too short to store FAMILY NAME (T_APPNAME length = 12+1 FAMILY NAME length =15+1)
  // Binary name is used instead. "info.file_name" contains the binary name with the file extension
  // (e.g. ABCDEFG.AGN) and must be removed to be returned in the 'is_name' function.
  indexExt = strstr(fileName, ".");
  if(indexExt != NULL) {
    *indexExt = '\0';
  }
}


#ifdef __cplusplus
}
#endif
